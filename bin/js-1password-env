#!/usr/bin/env python3
from __future__ import annotations

import json
import logging
import os
import subprocess
from dataclasses import dataclass, field
from pathlib import Path

import yaml
from collections import defaultdict

LOGGER = logging.getLogger(__name__)
logging.basicConfig(level=os.environ.get("LOGLEVEL", "INFO"))

cwd = Path.cwd()

# ──────────────────────────────────────────────────────────────
# Models
# ──────────────────────────────────────────────────────────────

@dataclass
class ConfigDefaults:
    vault: str | None = None


@dataclass
class ConfigItemSpec:
    item: str
    field: str | None = None
    vault: str | None = None


@dataclass
class ConfigFileSpec:
    name: str | list[str]
    items: dict[str, ConfigItemSpec]


@dataclass
class Config:
    defaults: ConfigDefaults = field(default_factory=ConfigDefaults)
    files: list[ConfigFileSpec] = field(default_factory=list)


@dataclass
class InputsArgs:
    config_file: Path
    output_name: str


# ──────────────────────────────────────────────────────────────
# CLI helpers
# ──────────────────────────────────────────────────────────────

def parse_args(argv: list[str]) -> InputsArgs:
    """
    Parse command-line arguments manually.

    Supports:
      1password_env --config-file=/path/to/.1password_env.yml ".env"
      1password_env ".env"
    """
    config_file: Path | None = None
    output_name: str | None = None

    for arg in argv[1:]:
        if arg.startswith("--config-file="):
            config_file = Path(arg.split("=", 1)[1])
        elif arg.startswith("-c="):  # optional short form
            config_file = Path(arg.split("=", 1)[1])
        elif not output_name:
            output_name = arg
        else:
            print(f"⚠️ Ignoring unexpected argument: {arg}")

    if output_name is None:
        raise ValueError("No output name specified")

    if config_file is None:
        config_file = cwd / ".1password-env.yml"

    if not config_file.exists():
        raise FileNotFoundError(f"File {config_file} does not exist")

    return InputsArgs(
        config_file=config_file,
        output_name=output_name,
    )


def run_op_command(args: list[str]) -> str:
    """Run a 1Password CLI command and return stdout."""
    result = subprocess.run(
        ["op"] + args,
        capture_output=True,
        text=True,
        )
    if result.returncode != 0:
        raise RuntimeError(f"1Password CLI failed: {result.stderr.strip()}")
    return result.stdout.strip()


def get_item_fields(item_name: str, vault: str) -> dict[str, str]:
    """Return a mapping of label→value for all fields in a 1Password item."""
    output = run_op_command([
        "item", "get", item_name,
        "--vault", vault,
        "--format", "json",
        "--reveal"
    ])
    data = json.loads(output)
    fields: dict[str, str] = {}
    for a_field in data.get("fields", []):
        label = a_field.get("label")
        value = a_field.get("value")
        if label and value is not None:
            fields[label] = str(value)
    return fields


# ──────────────────────────────────────────────────────────────
# Config parsing
# ──────────────────────────────────────────────────────────────

def load_config(path: Path) -> Config:
    """Load and parse a .1password-env.yml file."""
    with open(path, "r", encoding="utf-8") as f:
        raw = yaml.safe_load(f)

    defaults = ConfigDefaults(**(raw.get("_default_", {}) or {}))
    files_data = raw.get("files", []) or []

    files: list[ConfigFileSpec] = []
    for fdata in files_data:
        items = {
            key: ConfigItemSpec(**value)
            for key, value in (fdata.get("items") or {}).items()
        }
        files.append(ConfigFileSpec(name=fdata["name"], items=items))
    return Config(defaults=defaults, files=files)


# ──────────────────────────────────────────────────────────────
# Core logic
# ──────────────────────────────────────────────────────────────

def generate_env_file(file_spec: ConfigFileSpec, defaults: ConfigDefaults) -> tuple[str, list[str]]:
    """Generate .env file content for a given FileSpec."""
    grouped: dict[tuple[str, str], list[tuple[str, str]]] = defaultdict(list)
    # key = (item_name, vault), value = list of (env_var, field_name)

    for env_var, spec in file_spec.items.items():
        vault = spec.vault or defaults.vault
        if not vault:
            raise ValueError(f"No vault specified for {env_var}")
        field_name = spec.field or env_var
        grouped[(spec.item, vault)].append((env_var, field_name))

    env_lines: list[str] = []

    for (item_name, vault), entries in grouped.items():
        fields = get_item_fields(item_name, vault)
        for env_var, field_name in entries:
            value = fields.get(field_name)
            if value is None:
                LOGGER.warning(
                    f"⚠️ Field '{field_name}' not found in item '{item_name}' "
                    f"(for env var '{env_var}')"
                )
                continue
            env_lines.append(f"{env_var}={value}")

    return file_spec.name, env_lines


# ──────────────────────────────────────────────────────────────
# Entry point
# ──────────────────────────────────────────────────────────────

def main(input_args: InputsArgs) -> None:
    """Entry point for the 1Password env writer."""

    config = load_config(input_args.config_file)

    written = False
    for file_spec in config.files:
        if (
            (isinstance(file_spec.name, list) and input_args.output_name in file_spec.name)
            or (isinstance(file_spec.name, str) and input_args.output_name == file_spec.name)
        ):
            name, lines = generate_env_file(file_spec, config.defaults)
            output_path = input_args.config_file.parent / name
            output_path.write_text("\n".join(lines) + "\n", encoding="utf-8")
            LOGGER.info(f"✅ Wrote {output_path} with {len(lines)} entries.")
            written = True

    if not written:
        raise RuntimeError(f"Output name not found, check {input_args.output_name=} exists in the config!")


if __name__ == "__main__":
    import sys
    inputs = parse_args(sys.argv)
    main(inputs)
